---
title: "ABPRS R Package Tutorial"
output: html_document
vignette: >
  %\VignetteIndexEntry{ABPRS}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo=FALSE, include = FALSE}
library(ABPRS)
library(dplyr)
library(ROCR)
library(glmnet)
library(biglasso)
library(readr)
library(data.table)
library(ggplot2)
library(ggh4x)
library(plotly)
library(tableHTML)
library(htmlwidgets)
library(DT)
```

Welcome to the AB-PRS R package tutorial! In this guide, you will learn how to use the packageâ€™s functions in two distinct ways. The first approach is straightforward: you can use the `ABPRS` function to directly obtain the selected $\theta_{SNP}$ supports and their corresponding weights ([Example 1](#eg1)). The second approach walks you through using individual helper functions, each corresponding to a step in the AB-PRS flowchart, or Figure 1 in the paper ([Example 2](#eg2)). The tutorial uses simulated datasets generated by a function within the package, so no external data downloads are necessary. For demonstrative purposes, we will be generating binary outcomes in the first example and continuous outcomes in the second one.

Below is a list of all functions available in the package, each of which will be covered in detail. For more specific information about any of these functions, you can refer to the user manual by using the help command `?function_name` after the package is loaded in your R environment: 

 * **`ABPRS`**: the main AB-PRS function to obtain weights for selected $\theta_{SNPs}$. 

 * **`apply_weights`**: a helper function to apply weights to a data.

 * **`learning_theta_snps`**: learns `theta1` and `theta2` values.

 * **`encoding_theta_snps`**: encodes $\theta_{SNPs}$ on genotype data.

 * **`adaptive_variable_selection`**: selects important $\theta_{SNPs}$ (supports).

 * **`data_simulation`**: generates simulated datasets used in the paper.

 * **`model_evaluation`**: evaluates the performance of different PRS models.

# Installation and Loading

### Install library

To install the AB-PRS package, please run the following function in R: 

```{r, eval=FALSE}
remotes::install_github("Cedars-CIG/ABPRS") 
```

### Load library

After installing the AB-PRS package, you can use it the same way as you use other R packages. Simply load it using the code below and use `?` to view the user manual of a specific function. 

```{r}
library(ABPRS)
```

# Example 1: Overall Function on Simulated Dataset with Binary Outcome {#eg1}

### Part 1: Data Generation and Splitting {#eg1p1}

First, you need to generate the simulated data, specifically the phenotype and genotype information. The `data_simulation` function in our package allows users to generate those information at ease with high customization.

Using the following code, you will generate data for 10,000 individuals with 250 SNPs, including 25 additive, 25 codominant, and 200 non-effective SNPs. All SNPs have a minor allele frequency (MAF) of 0.3. Furthermore, this example generates binary phenotypes. The effect size is set to 0.7, and the baseline effect (beta0) is -19.5, which maintains the case prevalence to around 30% in this dataset. Note that a larger beta value will result in fewer case outcomes.

For more details on how the outcomes are generated, please refer to the manual by running `?data_simulation` in R.

```{r data simulation}
data <- data_simulation(m=250, effect_snps_vec = c(25, 0, 0, 25), n=10000, 
                        maf=0.3, effect_size=0.7, beta0= (-19.5), binary = TRUE)
```

From the simulation function, a dataframe with phenotype in the first column and 
genotype in the rest of the columns is produced. 

```{r, echo=FALSE}
str(data, list.len=0)
knitr::kable(data[1:8,1:11], row.names=TRUE, format="markdown")
```

As you can see, the case outcome is ~30% using the above combination of parameters:
```{r}
mean(data[,1])
```

Now that you have the data, you can divide them for training, validation, and testing 
purposes. The following code produce three non-overlapping partitions with 50%, 
25%, and 25% of the data respectively. 

```{r sampling}
sample <- sample(1:3,size=10000,replace=T,prob=c(0.5, 0.25, 0.25))
data_train = data[which(sample==1),]
data_val = data[which(sample==2),]
data_test = data[which(sample==3),]
rm(sample)
```

For clarity in upcoming analysis, you can store the data into separate variables.

```{r}
training_phenotype = data_train[,1]
validation_phenotype = data_val[,1]
testing_phenotype = data_test[,1]

training_genotype = data_train[,-1]
validation_genotype = data_val[,-1]
testing_genotype = data_test[,-1]

rm(data_test, data_train, data_val)
```

### Part 2: Generate pre-trained polygenic risk scores (pre-trained PRSs) {#eg2p2}

Next, you need to generate pre-trained polygenic risk scores.In this example, we first run a simple binomial regression model on the training data to obtain GWAS effect sizes (betas). Then, we apply these betas to the training, validation, and testing genotypes using matrix multiplication. For real datasets, you can use PRSice, PLINK P+T, PRScs, LDPred2, or any method to generate the pre-trained PRSs.

```{r}
#Generate GWAS on training dataset
gwas <- matrix(nrow=250,ncol=2)
for (i in 1:250){
  gwas[i,1]<-summary(glm(training_phenotype~training_genotype[,i],family="binomial"))$coef[2,1]
  gwas[i,2]<-i
}
  
# PRS calculation
training_prs <- as.matrix(training_genotype[,(gwas[,2])])%*%as.matrix(gwas[,1])
validation_prs <- as.matrix(validation_genotype[,(gwas[,2])])%*%as.matrix(gwas[,1])
testing_prs <- as.matrix(testing_genotype[,(gwas[,2])])%*%as.matrix(gwas[,1])
```

Here are snapshots of the pre-trained polygenic risk scores for this particular training, validation, and testing data:
```{r}
str(training_prs, give.attr = FALSE)
str(validation_prs, give.attr = FALSE)
str(testing_prs, give.attr = FALSE)
```

### Part 3: AB-PRS Function

Now that you have the phenotype, genotype, and pre-trained PRSs of the split datasets, you can run the AB-PRS function! The AB-PRS function generates weights of the pre-trained polygenic risk scores and that of the selected $\theta_{SNPs}$. This function also outputs the theta1 and theta2 values of the selected $\theta_{SNPs}$, which are the corrected theta encodings for heterozygous (Aa) and homozygous alternative (aa) alleles, respectively. 

Note that this function includes many parameters, with the first seven being required fields. You can learn about each parameter and their corresponding default values in detail by running `?ABPRS` in R. 

```{r}
weights <- ABPRS(pre_trained_prs = training_prs, validation_prs=validation_prs, 
                 training_genotype=training_genotype, validation_genotype=validation_genotype,
                 training_phenotype=training_phenotype, validation_phenotype=validation_phenotype,
                 family="binomial", covariate=NULL, biglasso=FALSE, 
                 lam.max=NULL, lam.min=NULL, nlambda=100,
                 alpha=0.1, tolerance=0.025, threshold=0.01,
                 err=1e-5, delta=NULL)
```

Here is a snapshot of the output of the ABPRS function:
```{r, echo=FALSE}
knitr::kable(head(weights[1:5, 1:3]), format="markdown")
```

Here are all the SNPs selected as supports: 
```{r}
rownames(weights)[-1]
```

Next, use the `apply_weights` helper function to apply the generated weights to datasets like the testing or external data, producing the final AB-PRSs!

```{r}
testing_abprs <- apply_weights(testing_prs, testing_genotype, weights)
```

Here is a summary of the resulting dataframe:
```{r}
str(testing_abprs)
```

### Part 4: Model Evaluation

Lastly, you can evaluate various PRS models using the model evaluation function. Here, we compare the performance of the pre-trained PRS and AB-PRS.

```{r}
model_evaluation(phenotype=testing_phenotype, 
                 'Pre-Trained PRS' = testing_prs, 
                 'AB-PRS' = testing_abprs,
                 binary = TRUE, 
                 bin=10,
                 filename="Evaluation_Binary")
```

After the model evaluation function, an html file would be produced. 

<center><iframe src="Evaluation_Binary.html" height="800" width="920" style="border: 1px solid #464646;" allowfullscreen="" allow="autoplay" data-external="1"></iframe></center>

# Example 2: Step-by-step Function on Simulated Dataset with Continuous Outcome {#eg2}

In addition to the main ABPRS function, this package also includes functions corresponding to each step of the AB-PRS flowchart, offering better understanding and customization.

### Part 1: Data Generation and Splitting

In this example, we will use simulated dataset with continuous outcome.

Using the following code, you will generate data for 10,000 individuals with 250 SNPs, including 25 additive, 25 codominant, and 200 non-effective SNPs. All SNPs have a minor allele frequency (MAF) of 0.3. Continuous phenotype is generated with an effect size of 0.3 and baseline measurement of -1.

```{r}
data <- data_simulation(m=250, effect_snps_vec = c(25, 0, 0, 25), n=10000, 
                        maf=0.3, effect_size=0.3, beta0= (-1), binary = FALSE)
```

Here is a snapshot of the generated dataset:

```{r, echo=FALSE}
knitr::kable(data[1:8,1:9], format="markdown")
```

Now that you have the data, you can divide them into training, validation, and testing datasets, and separate the phenotype and genotype for clarity (similar to [Example 1](#eg1p1)). Once again, we are creating three non-overlapping partitions containing 50%, 25%, and 25% of the data, respectively.

```{r}
sample <- sample(1:3,size=10000,replace=T,prob=c(0.5, 0.25, 0.25))
data_train = data[which(sample==1),]
data_val = data[which(sample==2),]
data_test = data[which(sample==3),]
rm(sample)

training_phenotype = data_train[,1]
validation_phenotype = data_val[,1]
testing_phenotype = data_test[,1]

training_genotype = data_train[,-1]
validation_genotype = data_val[,-1]
testing_genotype = data_test[,-1]

rm(data_test, data_train, data_val)
```

### Part 2: Calculate pre-trained polygenic risk scores

To generate the pre-trained polygenic risk scores, we use the same method as with [Example 1](#eg1p2), but change the family object for regression models from `binomial` to `gaussian`. 

```{r}
#Generate GWAS on training dataset
gwas <- matrix(nrow=250,ncol=2)
for (i in 1:250){
  gwas[i,1]<-summary(glm(training_phenotype~training_genotype[,i],family="gaussian"))$coef[2,1]
  gwas[i,2]<-i
}
  
# PRS calculation
training_prs <- as.matrix(training_genotype[,(gwas[,2])])%*%as.matrix(gwas[,1])
validation_prs <- as.matrix(validation_genotype[,(gwas[,2])])%*%as.matrix(gwas[,1])
testing_prs <- as.matrix(testing_genotype[,(gwas[,2])])%*%as.matrix(gwas[,1])
```

### Part 3: AB-PRS Functions 

The AB-PRS process contains three main steps, shown in Figure 1 of the AB-PRS paper. This package provides functions to run the process step-by-step. 

#### Step 1: Convert genotype to new $\theta_{SNP}$ encoding

First, you will be converting a genotype matrix of any kind of encoding to a new $\theta_{SNP}$ encoding. To compute $\theta_{SNPs}$ encoding values, you should be using the training data with the `learning_theta_snps` function. Since we have a dataset with continuous outcomes, you should be using `"gaussian"` for the `family` parameter. Datasets with binary outcomes should use `"binomial"` instead. 

```{r}
thetas_mat <- learning_theta_snps(phenotype=training_phenotype, genotype=training_genotype,
                                  pre_trained_prs=training_prs, covariate=NULL, family="gaussian")
```

Here is what `thetas_mat` looks like: 

```{r, echo=FALSE}
knitr::kable(thetas_mat[1:8,1:4], format="markdown")
```

Then, we use the thetas matrix to turn our original genotype matrix with additive encoding to one with theta encoding. 

```{r}
theta_train <- encoding_theta_snps(training_genotype, thetas_mat)
theta_val <- encoding_theta_snps(validation_genotype, thetas_mat)
theta_test <- encoding_theta_snps(testing_genotype, thetas_mat)
```

Here's an example of what `theta_train` looks like:
```{r, echo=FALSE}
knitr::kable(theta_train[1:8,1:8], format="markdown")
```

#### Step 2: Select important $\theta_{SNPs}$ with adaptive variable selection and FDR control

Next, we use the `adaptive_variable_selection` function to select important $\theta_{SNPs}$ as supports. 

```{r}
support_ABPRS <- adaptive_variable_selection(pre_trained_prs = training_prs, 
                                            validation_prs = validation_prs,
                                            training_phenotype = training_phenotype, 
                                            validation_phenotype = validation_phenotype,
                                            training_theta_encoding = theta_train, 
                                            validation_theta_encoding = theta_val,
                                            family = "gaussian", biglasso = FALSE,
                                            lam.max = NULL, lam.min = NULL, nlambda = 100,
                                            alpha = 0.1, tolerance = 0.025, threshold = 0.01,
                                            err = 1e-05, delta = NULL)
```

Here are your supports:
```{r}
support_ABPRS
```

#### Step 3: Calculate final AB-PRS by boosting with fine-tuned $\theta_{SNPs}$

To calculate the final AB-PRS, you need to first train a model using the training PRS and the theta-encoded genotype of selected $\theta_{SNPs}$. 

```{r}
# Generate gaussian model from training data
trainABPRS <- data.frame(prs=training_prs, theta_train[,support_ABPRS])
modABPRS <- glm(training_phenotype ~ ., data = trainABPRS, family="gaussian")
```

Then, you can apply the weights derived from the above regression model to any data you wish. In this case, we applied the weights to the testing data. 
```{r}
# Apply the model to generate polygenic risk scores for testing data
testABPRS <- data.frame(prs=testing_prs, theta_test[,support_ABPRS])
testing_abprs = as.matrix(testABPRS)%*%modABPRS$coefficients[-1]
```

Here is what the AB-PRSs for the testing data look like:
```{r}
str(as.vector(testing_abprs))
```

### Part 4: Model Evaluation

Here, we compare the pre-trained PRS and AB-PRS models for continuous traits.

```{r}
model_evaluation(phenotype=testing_phenotype, 
                 'Pre-Trained PRS' = testing_prs, 
                 'AB-PRS' = testing_abprs,
                 binary = FALSE, 
                 bin=10,
                 filename="Evaluation_Continuous")
```

After the model evaluation function, an html file would be produced. 

<center><iframe src="Evaluation_Continuous.html" height="800" width="920" style="border: 1px solid #464646;" allowfullscreen="" allow="autoplay" data-external="1"></iframe></center>