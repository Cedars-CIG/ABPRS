---
title: "ABPRS R Package Tutorial"
output: html_document
vignette: >
  %\VignetteIndexEntry{ABPRS}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo=FALSE, include = FALSE}
library(ABPRS)
library(dplyr)
library(ROCR)
library(glmnet)
library(biglasso)
library(readr)
library(data.table)
library(ggplot2)
library(ggh4x)
library(plotly)
library(tableHTML)
library(htmlwidgets)
library(DT)
```

Welcome to the AB-PRS R package tutorial! In this guide, you will learn how to use the package's main functions, including both the overall workflow ([Example 1](#eg1)) and step-by-step functions ([Example 2](#eg2)) for the AB-PRS process. This tutorial uses simulated datasets generated by a function within the AB-PRS package, so no additional data downloads are required. 

Below is a list of the key functions available in the package, each of which will be covered in detail. For more specific information about any of these functions, you can refer to the user manual by using the help command `?function_name`: 

 * **`ABPRS`**: the main AB-PRS function to obtain weights for selected $\theta_{SNPs}$. 

 * **`apply_weights`**: a helper function to apply weights to a data.

 * **`learning_theta_snps`**: learns `theta1` and `theta2` values.

 * **`encoding_theta_snps`**: encodes $\theta_{SNPs}$ on genotype data.

 * **`adaptive_variable_selection`**: selects important $\theta_{SNPs}$ (supports).

 * **`data_simulation`**: generates simulated datasets used in the paper.

 * **`model_evaluation`**: evaluates the performance of different PRS models.

# Installation and Loading

### Install library

To install the AB-PRS package, please run the following function in R: 

```{r, eval=FALSE}
remotes::install_github("Cedars-CIG/ABPRS") 
```

### Load library

After installing the AB-PRS package, you can use it the same way as you use other R packages. Simply load it using the code below and use `?` to view the user manual of a specific function. 

```{r}
library(ABPRS)
```

# Example 1: Overall Function on Simulated Dataset with Binary Outcome {#eg1}

### Part 1: Data Generation and Splitting {#eg1p1}

First, you need to generate the simulated data, specifically the phenotype and genotype information. The `data_simulation` function in our package allows users to generate those information at ease with high customization.

Using the following code, you will generate data for 10,000 individuals with 250 SNPs, including 25 additive, 25 codominant, and 200 non-effective SNPs. All SNPs have a minor allele frequency (MAF) of 0.3. Furthermore, this example generates binary phenotypes. The effect size is set to 0.7, and the baseline effect (beta0) is -19.5, which maintains the case prevalence to between 30% and 40% in this dataset. Note that a larger beta value will result in fewer case outcomes.

For more details on how the outcomes are generated, please refer to the manual by running `?data_simulation` in R.

```{r data simulation}
data <- data_simulation(m=250, effect_snps_vec = c(25, 0, 0, 25), n=10000, 
                        maf=0.3, effect_size=0.7, beta0= (-19.5), binary = TRUE)
```

From the simulation function, a dataframe with phenotype in the first column and 
genotype in the rest of the columns is produced. 

```{r, echo=FALSE}
str(data, list.len=0)
knitr::kable(data[1:8,1:11], row.names=TRUE, format="markdown")
```

As you can see, the case outcome is ~30-40% using the above combination of parameters:
```{r}
mean(data[,1])
```

Now that you have the data, you can divide them for training, validation, and testing 
purposes. The following code produce three non-overlapping partitions with 50%, 
25%, and 25% of the data respectively. 

```{r sampling}
sample <- sample(1:3,size=10000,replace=T,prob=c(0.5, 0.25, 0.25))
data_train = data[which(sample==1),]
data_val = data[which(sample==2),]
data_test = data[which(sample==3),]
rm(sample)
```

For clarity in upcoming analysis, you can store the data into separate variables.

```{r}
training_phenotype = data_train[,1]
validation_phenotype = data_val[,1]
testing_phenotype = data_test[,1]

training_genotype = data_train[,-1]
validation_genotype = data_val[,-1]
testing_genotype = data_test[,-1]

rm(data_test, data_train, data_val)
```

### Part 2: Generate pre-trained polygenic risk scores (pre-trained PRSs) {#eg2p2}

Next, you need to generate pre-trained polygenic risk scores.In this example, we first run a simple binomial regression model on the training data to obtain GWAS effect sizes (betas). Then, we apply these betas to the training, validation, and testing genotypes using matrix multiplication. For real datasets, you can use external GWAS summary statistics and any method to generate pre-trained PRSs.

```{r}
#Generate GWAS on training dataset
gwas <- matrix(nrow=250,ncol=2)
for (i in 1:250){
  gwas[i,1]<-summary(glm(training_phenotype~training_genotype[,i],family="binomial"))$coef[2,1]
  gwas[i,2]<-i
}
  
# PRS calculation
training_prs <- as.matrix(training_genotype[,(gwas[,2])])%*%as.matrix(gwas[,1])
validation_prs <- as.matrix(validation_genotype[,(gwas[,2])])%*%as.matrix(gwas[,1])
testing_prs <- as.matrix(testing_genotype[,(gwas[,2])])%*%as.matrix(gwas[,1])
```

Here are snapshots of the pre-trained polygenic risk scores for this particular training, validation, and testing data:
```{r}
str(training_prs, give.attr = FALSE)
str(validation_prs, give.attr = FALSE)
str(testing_prs, give.attr = FALSE)
```

### Part 3: AB-PRS Function

Now that you have the phenotype, genotype, and pre-trained PRSs of the split datasets, you can run the AB-PRS function! The AB-PRS function generates weights of the pre-trained polygenic risk scores and that of the selected \eqn{\theta_{SNPs}}. This function also outputs the theta1 and theta2 values of the selected \eqn{\theta_{SNPs}}, which are the corrected theta encodings for heterozygous (Aa) and homozygous alternative (aa) alleles, respectively. 

Note that this function includes many parameters, with the first seven being required fields. Since this method uses lasso selection, tuning lambda values through trial and error may be necessary for optimal performance. Generally, you can start with the default value and adjust by increasing `lam.max` twofold and decreasing `lam.min` twofold until optimal results are achieved. In this example, we are using the default values for all non-required fields.

You can learn about each parameter and their corresponding default values in detail by running `?ABPRS` in R. 

```{r}
weights <- ABPRS(pre_trained_prs = training_prs, validation_prs=validation_prs, 
                 training_genotype=training_genotype, validation_genotype=validation_genotype,
                 training_phenotype=training_phenotype, validation_phenotype=validation_phenotype,
                 family="binomial")
```

Here is a snapshot of the output of the ABPRS function:
```{r, echo=FALSE}
knitr::kable(head(weights[1:5, 1:3]), format="markdown")
```

Here are all the SNPs selected as supports: 
```{r}
rownames(weights)[-1]
```

Next, use the `apply_weights` helper function to apply the generated weights to datasets like the testing or external data, producing the final AB-PRSs!

```{r}
testing_abprs <- apply_weights(testing_prs, testing_genotype, weights)
```

Here's a summary of the resulting dataframe:
```{r}
str(testing_abprs)
```

### Part 4: Model Evaluation

Lastly, you can evaluate the PRS models. 

```{r}
model_evaluation(phenotype=testing_phenotype, 
                 'Pre-Trained PRS' = testing_prs, 
                 'ABPRS' = testing_abprs,
                 binary = TRUE, 
                 bin=10)
```

After the model evaluation function, an html file would be produced. 

Note: if the iframe below does not appear, please checkout `\vignettes\Evaluation.html`  on github. 

<center><iframe src="Evaluation.html" height="800" width="920" style="border: 1px solid #464646;" allowfullscreen="" allow="autoplay" data-external="1"></iframe></center>

# Example 2: Step-by-step Function on Simulated Dataset with Continuous Outcome {#eg2}

In addition to the main ABPRS function, this package also includes functions corresponding to each step of the AB-PRS flowchart, offering better understanding and customization.

### Part 1: Data Generation and Splitting

In this example, we will use simulated dataset with continuous outcome.
```{r}
data <- data_simulation(m=250, effect_snps_vec = c(25, 0, 0, 25), n=10000, 
                        maf=0.3, effect_size=0.3, beta0= (-1), binary = FALSE)
```

Here is a snapshot of the generated dataset:

```{r, echo=FALSE}
knitr::kable(data[1:8,1:9], format="markdown")
```

Now that you have the data, you can divide them into training, validation, and testing datasets, and separate the phenotype and genotype for clarity (similar to [Example 1](#eg1p1)). Once again, we are creating three non-overlapping partitions containing 50%, 25%, and 25% of the data, respectively.

```{r}
sample <- sample(1:3,size=10000,replace=T,prob=c(0.5, 0.25, 0.25))
data_train = data[which(sample==1),]
data_val = data[which(sample==2),]
data_test = data[which(sample==3),]
rm(sample)

training_phenotype = data_train[,1]
validation_phenotype = data_val[,1]
testing_phenotype = data_test[,1]

training_genotype = data_train[,-1]
validation_genotype = data_val[,-1]
testing_genotype = data_test[,-1]

rm(data_test, data_train, data_val)
```

### Part 2: Calculate pre-trained polygenic risk scores

To generate the pre-trained polygenic risk scores, we use the same method as with [Example 1](#eg1p2), but just changed the family from binomial to gaussian. 

```{r}
#Generate GWAS on training dataset
gwas <- matrix(nrow=250,ncol=2)
for (i in 1:250){
  gwas[i,1]<-summary(glm(training_phenotype~training_genotype[,i],family="gaussian"))$coef[2,1]
  gwas[i,2]<-i
}
  
# PRS calculation
training_prs <- as.matrix(training_genotype[,(gwas[,2])])%*%as.matrix(gwas[,1])
validation_prs <- as.matrix(validation_genotype[,(gwas[,2])])%*%as.matrix(gwas[,1])
testing_prs <- as.matrix(testing_genotype[,(gwas[,2])])%*%as.matrix(gwas[,1])
```

### Part 3: AB-PRS Functions 

The AB-PRS process contains three main steps, shown in Figure 1 of the AB-PRS paper. This package provides functions to run the process step-by-step. 

#### Step 1: Convert genotype to \eqn{\theta_{SNPs}} encoding

First, you will be converting a genotype matrix of any kind of encoding to a new \eqn{\theta_{SNP}} encoding. To compute \eqn{\theta_{SNPs}} encoding values, you should be using the training data with the `learning_theta_snps` function. Since we have a dataset with continuous outcomes, you should be using `"gaussian"` for the `family` parameter. Datasets with binary outcomes should use `"binomial"` instead. 

```{r}
thetas_mat <- learning_theta_snps(phenotype=training_phenotype, genotype=training_genotype,
                                  pre_trained_prs=training_prs, covariate=NULL, family="gaussian")
```

Here is what `thetas_mat` looks like: 

```{r, echo=FALSE}
knitr::kable(thetas_mat[1:8,1:4], format="markdown")
```

Then, we use the thetas matrix to turn our original genotype matrix with additive encoding to one with theta encoding. 

```{r}
theta_train <- encoding_theta_snps(training_genotype, thetas_mat)
theta_val <- encoding_theta_snps(validation_genotype, thetas_mat)
theta_test <- encoding_theta_snps(testing_genotype, thetas_mat)
```

Here's an example of what `theta_train` looks like:
```{r, echo=FALSE}
knitr::kable(theta_train[1:8,1:8], format="markdown")
```

#### Step 2: Adaptive Variable Selection 

Next, we use the `adaptive_variable_selection` function to select important \eqn{\theta_{SNPs}} as supports. 

```{r}
support_ABPRS <- adaptive_variable_selection(pre_trained_prs = training_prs, 
                                            validation_prs = validation_prs,
                                            training_phenotype = training_phenotype, 
                                            validation_phenotype = validation_phenotype,
                                            training_theta_encoding = theta_train, 
                                            validation_theta_encoding = theta_val,
                                            family = "gaussian", biglasso = FALSE,
                                            lam.max = 0.3, lam.min = 0.0001, nlambda = 100,
                                            alpha = 0.1, tolerance = 0.025, threshold = 0.01,
                                            err = 1e-05, delta = NULL)
```

Here are your supports:
```{r}
support_ABPRS
```

#### Step 3: Calculate final AB-PRS by boosting with selected \eqn{\theta_{SNPs}}

To calculate the final AB-PRS, you need to first train a model using the training PRS and the theta-encoded genotype of selected \eqn{\theta_{SNPs}}. 

```{r}
# Generate gaussian model from training data
trainABPRS <- data.frame(prs=training_prs, theta_train[,support_ABPRS])
modABPRS <- glm(training_phenotype ~ ., data = trainABPRS, family="gaussian")
```

Then, you can apply the weights derived from the above regression model to any data you wish. In this case, we applied the weights to the testing data. 
```{r}
# Apply the model to generate polygenic risk scores for testing data
testABPRS <- data.frame(prs=testing_prs, theta_test[,support_ABPRS])
testing_abprs = as.matrix(testABPRS)%*%modABPRS$coefficients[-1]
```

Here is what the AB-PRSs for the testing data look like:
```{r}
str(testing_abprs)
```

And you're done! Feel free to try evaluate the model yourself for this example. 